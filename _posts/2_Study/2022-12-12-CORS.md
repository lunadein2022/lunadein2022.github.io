---
layout: post
title: "CORS?"
date: 2022-12-11 16:49:14 +0900
categories: home study
---

# SOP

= 정책

Same-Origin Policy = 동일출처정책

같은 출처의 리소스만 공유가 가능하다

출처?

(출처 = 프로토콜 + 호스트 + 포트 ) 이 중 하나라도 다르면 동일 출처 아님

![스크린샷 2022-12-11 오후 9.17.21.png](basic%20014e626dc96a4c50a8b33f38d4750e95/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-12-11_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.17.21.png)

\*https 의 기본포트 = 443

\*잠재적으로 해로울 수 있는 문서를 분리함으로써 공격받을 수 있는 경로를 줄여준다. (해킹 등의 위협에서 보다 더 안전) (다른 사이트와의 리소스 공유 제한)

\*근데 다른 출처의 리소스를 사용할 일이 생기면?

개발중인 웹사이트에서 네이버 지도 api 필요

깃헙에서 정보를 받아서 사용하고 싶다면

⇒ 다른 출처의 리소스 사용하는 일

# CORS

\*그래서 필요한게 Cross-Origin Resource Sharing (CORS) = 교차 출처 리소스 공유

= 추가 HTTP헤더 사용, 한 출처에서 실행중인 웹애플리케이션이 다른 출처의 선택한 자원에 접근할 수 있는 권한을 부여하도록 브라우저에 알려주는 체제

SOP에 의해 막힌 다른 출처의 리소스 공유 → CORS로 접근권한 얻음

## 동작방식

3가지 있음

### 1. 프리플라이트 요청

= 실제 요청 보내기 전, OPTIONS 메서드로 사전요청 보내 해당 출처 리소스에 접근 권한이 있는지부터 확인

![스크린샷 2022-12-11 오후 9.32.18.png](basic%20014e626dc96a4c50a8b33f38d4750e95/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-12-11_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.32.18.png)

- 서버에 실제 요청 보내기 전 프리플라이트 요청 보내고
  응답헤더의 `Access-Control-Allow-Origin` 으로 요청을 보낸 출처가 돌아오면 실제 요청 보냄
  ![스크린샷 2022-12-11 오후 9.33.53.png](basic%20014e626dc96a4c50a8b33f38d4750e95/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-12-11_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.33.53.png)
- 요청 보낸 출처가 접근권한이 없다면 브라우저에서 CORS 에러를 띄우고 실제 요청 전달 안됨

## IF?

![스크린샷 2022-12-11 오후 9.36.59.png](basic%20014e626dc96a4c50a8b33f38d4750e95/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-12-11_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.36.59.png)

위와같이 서버에 우선 요청을 보내면 서버는 응답 보내기 전에 요청 우선 처리함. (그러고 나서 응답보냄)

브라우저는 응답 받고나서야 아 클라이언트 얘 이거 권한없었네 하고 깨달았지만 이미 요청은 수행되었는걸..!

만약 요청내용이 DELETE 나 PUT처럼 서버정보 삭제나 수정하는 거였다면? NO….

BUT,

CORS에 대비가 되어 있지않은 서버라도 프리플라이트 요청을 먼저 보내면 그 선에서 CORS에러로 걸러지기 때문에 예시처럼의 크로스 오리진 요청이 실행되는걸 방지할 수있다.

= 프리플라이트 요청이 CORS기본사양으로 들어가게 되었다!

### 프리플라이트 요청 왜 필요함?

- 실제 요청 보내기 전에 미리 권한 확인하니까 실제 요청을 통째로 처음부터 보내는 것보다 리소스 측면에서 효율적
- CORS에 대비가 되어 있지 않은 서버를 보호할 수 있다.
  - CORS 이전에 만들어진 서버들은 SOP요청만 들어오는 상황을 고려하고 만들어짐.
    ⇒ 다른 출처에서 들어오는 요청에 대한 대비가 안되어있음.

### 2. 단순 요청

= 특정 조건이 만족되면 프리플라이트 요청을 생략하고 요청 보냄

![스크린샷 2022-12-11 오후 9.29.04.png](basic%20014e626dc96a4c50a8b33f38d4750e95/%25E1%2584%2589%25E1%2585%25B3%25E1%2584%258F%25E1%2585%25B3%25E1%2584%2585%25E1%2585%25B5%25E1%2586%25AB%25E1%2584%2589%25E1%2585%25A3%25E1%2586%25BA_2022-12-11_%25E1%2584%258B%25E1%2585%25A9%25E1%2584%2592%25E1%2585%25AE_9.29.04.png)

조건은 아래와 같으나 모두 만족시키기 어려우므로 참고만 하라

- `GET` `HEAD` `POST` 요청 중 하나여야함
- 자동으로 설정되는 헤더 외에 `Accept` `Accept-Language` `Content-Language` `Content-Type` 헤더 값만 수동 설정 가능
  - Content-Type헤더에는 `application.x-www-form-urlencoded` `multipart/form-data` `text/plain` 값만 허용

### 3. 인증정보를 포함한 요청

= 요청 헤더에 인증 정보를 담아 보냄 (출처가 다를 경우 → 별도 설정 안하면 쿠키 못 보냄 /민감한 정보이기때문 ⇒ 프론트, 서버 양측 모두 CORS 설정 필요)

프론트측의 요청헤더 → `withCredentials : true`

서버측의 응답헤더 → `Access-Control-Allow-Credentials : true`

서버측에서 응답헤더 설정할 때 모든 출처 허용한단 뜻의 와일드카드(\*) 설정하면 에러 발생.
인증정보 다루는거니까 출처 정확하게 설정하라

# CORS Setting

## Node.js 서버

아래와 같이 응답헤더 설정

```jsx
const http = require("http");

const server = http.createServer((request, response) => {
  // 모든 도메인
  response.setHeader("Access-Control-Allow-Origin", "*");

  // 특정 도메인
  response.setHeader("Access-Control-Allow-Origin", "https://codestates.com");

  // 인증 정보를 포함한 요청을 받을 경우
  response.setHeader("Access-Control-Allow-Credentials", "true");
});
```

## Express 서버

cors 미들웨어를 사용해 더 간단히 CORS 설정

```jsx
const cors = require("cors");
const app = express();

//모든 도메인
/app.use(cors());

//특정 도메인
const options = {
	origin: "https://codestates.com", //접근 권한을 부여하는 도메인
	credentials: true, //응답 헤더에 Access-Control-Allow-Credentials 추가
	optionSuccessStatus: 200, //응답 상태 200으로 설정
};

app.use((options));

//특정 요청
app.get("/example/:id", cors(), function(req, res, next) {
	res.json({msg: "example"});
});
```
